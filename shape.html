<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Controlled 3D Particles</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  video { display:none; }
  #instructions {
    position:absolute;
    bottom:20px;
    left:20px;
    color:white;
    background:rgba(0,0,0,0.6);
    padding:12px;
    border-radius:8px;
    font-family:sans-serif;
  }
</style>
</head>
<body>

<div id="instructions">
  <h3>Hand Controls</h3>
  üñê Move Hand ‚Üí Rotate<br>
  üëå Pinch ‚Üí Change Shape<br>
  Shape: <span id="shape-name">Sphere</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ===== CONFIG ===== */
const MIRROR_X = -1; // üî• FIX
const PARTICLE_COUNT = 15000;
const shapes = ['Sphere','Heart','Saturn','Torus'];
let currentShape = 0;

/* ===== THREE ===== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 60;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== PARTICLES ===== */
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(PARTICLE_COUNT*3);
const target = new Float32Array(PARTICLE_COUNT*3);

for (let i=0;i<PARTICLE_COUNT;i++) {
  pos[i*3]=(Math.random()-0.5)*100;
  pos[i*3+1]=(Math.random()-0.5)*100;
  pos[i*3+2]=(Math.random()-0.5)*100;
}
geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

const mat = new THREE.PointsMaterial({
  size:0.4,
  color:0x00ffff,
  transparent:true,
  opacity:0.8,
  blending:THREE.AdditiveBlending
});

const particles = new THREE.Points(geo,mat);
scene.add(particles);

/* ===== SHAPES ===== */
function setShape(type) {
  document.getElementById("shape-name").innerText = shapes[type];
  for (let i=0;i<PARTICLE_COUNT;i++) {
    const a = Math.random()*Math.PI*2;
    target[i*3] = Math.cos(a)*25;
    target[i*3+1] = Math.sin(a)*25;
    target[i*3+2] = (Math.random()-0.5)*20;
  }
}
setShape(0);

/* ===== HANDS ===== */
const video = document.createElement("video");
const hands = new Hands({ locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });

hands.setOptions({ maxNumHands:1 });
hands.onResults(r=>{
  if (!r.multiHandLandmarks) return;

  const tip = r.multiHandLandmarks[0][8];
  const x = MIRROR_X * (tip.x - 0.5) * 2;
  const y = -(tip.y - 0.5) * 2;

  particles.rotation.y += x * 0.05;
  particles.rotation.x += y * 0.05;
});

new Camera(video,{
  onFrame:async()=>hands.send({image:video}),
  width:640,
  height:480
}).start();

/* ===== LOOP ===== */
function animate() {
  requestAnimationFrame(animate);

  const p = geo.attributes.position.array;
  for (let i=0;i<PARTICLE_COUNT;i++) {
    p[i*3] += (target[i*3]-p[i*3])*0.05;
    p[i*3+1] += (target[i*3+1]-p[i*3+1])*0.05;
    p[i*3+2] += (target[i*3+2]-p[i*3+2])*0.05;
  }
  geo.attributes.position.needsUpdate = true;

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>

