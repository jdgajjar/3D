<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Controlled 3D Particles</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: black;
}

video {
    position: absolute;
    transform: scaleX(-1);
    opacity: 0;
    pointer-events: none;
}

/* UI */
#instructions {
    position: fixed;
    bottom: 20px;
    left: 20px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 8px;
}

.ui-btn {
    position: fixed;
    top: 15px;
    padding: 10px 14px;
    border-radius: 8px;
    background: rgba(0,0,0,0.6);
    color: white;
    border: 1px solid rgba(255,255,255,0.3);
    cursor: pointer;
    font-size: 14px;
    backdrop-filter: blur(6px);
}

#change-btn { right: 15px; }
#back-btn { left: 15px; }

.ui-btn:hover {
    background: rgba(255,255,255,0.15);
}
</style>
</head>

<body>

<button id="back-btn" class="ui-btn">⬅ Back</button>
<button id="change-btn" class="ui-btn">Change Shape</button>

<div id="instructions">
    <b>Hand Controls</b><br>
    Move hand → Rotate<br>
    Pinch → Change shape<br>
    Shape: <span id="shape-name">Sphere</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ================= CONFIG ================= */
const PARTICLES = 15000;
let currentShape = 0;
let isPinching = false;
let lastPinch = 0;
let handVisible = false;

const targetRotation = new THREE.Vector2(0, 0);
const shapes = ["Sphere", "Heart", "Saturn", "Torus"];

/* ================= THREE ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = 60;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */
const geometry = new THREE.BufferGeometry();
const pos = new Float32Array(PARTICLES * 3);
const targetPos = new Float32Array(PARTICLES * 3);
const colors = new Float32Array(PARTICLES * 3);

const c = new THREE.Color();

for (let i = 0; i < PARTICLES; i++) {
    pos[i*3] = (Math.random() - 0.5) * 100;
    pos[i*3+1] = (Math.random() - 0.5) * 100;
    pos[i*3+2] = (Math.random() - 0.5) * 100;

    c.setHSL(0.55 + Math.random()*0.1, 0.8, 0.6);
    colors[i*3] = c.r;
    colors[i*3+1] = c.g;
    colors[i*3+2] = c.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(pos, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const points = new THREE.Points(
    geometry,
    new THREE.PointsMaterial({
        size: 0.4,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
    })
);

scene.add(points);

/* ================= SHAPES ================= */
function sphere(i) {
    const r = 25;
    const phi = Math.acos(-1 + (2*i)/PARTICLES);
    const theta = Math.sqrt(PARTICLES * Math.PI) * phi;
    return {
        x: r * Math.cos(theta) * Math.sin(phi),
        y: r * Math.sin(theta) * Math.sin(phi),
        z: r * Math.cos(phi)
    };
}

function heart(i) {
    const t = (i / PARTICLES) * Math.PI * 2;
    return {
        x: 16 * Math.pow(Math.sin(t), 3),
        y: 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t),
        z: (Math.random()-0.5)*10
    };
}

function saturn(i) {
    if (i > PARTICLES*0.7) {
        const a = Math.random()*Math.PI*2;
        const d = 35 + Math.random()*15;
        return { x: Math.cos(a)*d, y: 0, z: Math.sin(a)*d };
    }
    return sphere(i);
}

function torus() {
    const u = Math.random()*Math.PI*2;
    const v = Math.random()*Math.PI*2;
    return {
        x: (20 + 8*Math.cos(v))*Math.cos(u),
        y: (20 + 8*Math.cos(v))*Math.sin(u),
        z: 8*Math.sin(v)
    };
}

function setShape(type) {
    document.getElementById("shape-name").innerText = shapes[type];
    for (let i = 0; i < PARTICLES; i++) {
        let p;
        if (type === 0) p = sphere(i);
        if (type === 1) p = heart(i);
        if (type === 2) p = saturn(i);
        if (type === 3) p = torus();
        targetPos[i*3] = p.x;
        targetPos[i*3+1] = p.y;
        targetPos[i*3+2] = p.z;
    }
}
setShape(0);

/* ================= BUTTONS ================= */
document.getElementById("change-btn").onclick = () => {
    currentShape = (currentShape + 1) % shapes.length;
    setShape(currentShape);
};

document.getElementById("back-btn").onclick = () => {
    window.location.href = "index.html";
};

/* ================= MEDIAPIPE ================= */
const video = document.createElement("video");

const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
    maxNumHands: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(res => {
    if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
        handVisible = false;
        return;
    }

    handVisible = true;

    const lm = res.multiHandLandmarks[0];
    const index = lm[8];
    const thumb = lm[4];

    const x = -(index.x - 0.5) * 2;
    const y = (index.y - 0.5) * 2;

    targetRotation.y = THREE.MathUtils.clamp(x * 2, -1.2, 1.2);
    targetRotation.x = THREE.MathUtils.clamp(y * 2, -1.2, 1.2);

    const d = Math.hypot(index.x - thumb.x, index.y - thumb.y);
    if (d < 0.05 && !isPinching && Date.now() - lastPinch > 1000) {
        isPinching = true;
        lastPinch = Date.now();
        currentShape = (currentShape + 1) % shapes.length;
        setShape(currentShape);
    }
    if (d > 0.07) isPinching = false;
});

new Camera(video, {
    onFrame: async () => hands.send({ image: video }),
    width: 640,
    height: 480
}).start();

/* ================= LOOP ================= */
function animate() {
    requestAnimationFrame(animate);

    for (let i = 0; i < PARTICLES; i++) {
        const j = i*3;
        pos[j] += (targetPos[j] - pos[j]) * 0.05;
        pos[j+1] += (targetPos[j+1] - pos[j+1]) * 0.05;
        pos[j+2] += (targetPos[j+2] - pos[j+2]) * 0.05;
    }
    geometry.attributes.position.needsUpdate = true;

    if (!handVisible) {
        targetRotation.x *= 0.95;
        targetRotation.y *= 0.95;
    }

    points.rotation.x += (targetRotation.x - points.rotation.x) * 0.08;
    points.rotation.y += (targetRotation.y - points.rotation.y) * 0.08;
    points.rotation.z += 0.001;

    renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
