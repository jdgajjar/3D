<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Controlled 3D Particles</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
}

video {
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(-1);
    opacity: 0;
    pointer-events: none;
}

#instructions {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 8px;
}

/* üîπ Top-right button */
#back-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    padding: 10px 16px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    border: 1px solid #00ffff;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
}

#back-btn:hover {
    background: rgba(0,255,255,0.2);
}
</style>
</head>

<body>

<button id="back-btn" onclick="window.location.href='index.html'">
‚¨Ö Back
</button>

<div id="instructions">
    <h3>Hand Controls</h3>
    <p>üñê <b>Move Hand:</b> Rotate & Move Particles</p>
    <p>üëå <b>Pinch:</b> Switch Shape</p>
    <p>Current Shape: <span id="shape-name">Sphere</span></p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ---------------- CONFIG ---------------- */
const PARTICLE_COUNT = 15000;
const CAM_DEPTH = 60;
let currentShapeIndex = 0;
let isPinching = false;
let lastPinchTime = 0;

const targetRotation = new THREE.Vector2();
const shapes = ['Sphere', 'Heart', 'Saturn', 'Torus'];

/* ---------------- THREE SETUP ---------------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = CAM_DEPTH;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------------- PARTICLES ---------------- */
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

const color = new THREE.Color();

for (let i = 0; i < PARTICLE_COUNT; i++) {
    positions[i*3] = (Math.random() - 0.5) * 100;
    positions[i*3+1] = (Math.random() - 0.5) * 100;
    positions[i*3+2] = (Math.random() - 0.5) * 100;

    color.setHSL(0.55, 0.8, 0.6);
    colors[i*3] = color.r;
    colors[i*3+1] = color.g;
    colors[i*3+2] = color.b;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const particles = new THREE.Points(
    geometry,
    new THREE.PointsMaterial({
        size: 0.4,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true
    })
);
scene.add(particles);

/* ---------------- SHAPES ---------------- */
function getPointOnSphere(i) {
    const r = 25;
    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
    return {
        x: r * Math.cos(theta) * Math.sin(phi),
        y: r * Math.sin(theta) * Math.sin(phi),
        z: r * Math.cos(phi)
    };
}

function getPointOnTorus() {
    const u = Math.random() * Math.PI * 2;
    const v = Math.random() * Math.PI * 2;
    return {
        x: (20 + 8 * Math.cos(v)) * Math.cos(u),
        y: (20 + 8 * Math.cos(v)) * Math.sin(u),
        z: 8 * Math.sin(v)
    };
}

function setShape(type) {
    document.getElementById('shape-name').innerText = shapes[type];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const p = type === 3 ? getPointOnTorus() : getPointOnSphere(i);
        targetPositions[i*3] = p.x;
        targetPositions[i*3+1] = p.y;
        targetPositions[i*3+2] = p.z;
    }
}
setShape(0);

/* ---------------- MEDIAPIPE ---------------- */
const video = document.createElement('video');
const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({ maxNumHands: 1 });
hands.onResults(results => {
    if (!results.multiHandLandmarks) return;

    const lm = results.multiHandLandmarks[0];
    const indexTip = lm[8];

    /* üî• FIXED MIRROR ROTATION */
    const x = -(indexTip.x - 0.5) * 2; // inverted
    const y = -(indexTip.y - 0.5) * 2;

    targetRotation.x = y * 2;
    targetRotation.y = x * 2;

    const d = Math.hypot(lm[4].x - indexTip.x, lm[4].y - indexTip.y);
    if (d < 0.05 && !isPinching && Date.now() - lastPinchTime > 1000) {
        isPinching = true;
        lastPinchTime = Date.now();
        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        setShape(currentShapeIndex);
    }
    if (d >= 0.05) isPinching = false;
});

new Camera(video, {
    onFrame: async () => hands.send({ image: video }),
    width: 640,
    height: 480
}).start();

/* ---------------- ANIMATE ---------------- */
function animate() {
    requestAnimationFrame(animate);

    const p = geometry.attributes.position.array;
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const j = i * 3;
        p[j] += (targetPositions[j] - p[j]) * 0.05;
        p[j+1] += (targetPositions[j+1] - p[j+1]) * 0.05;
        p[j+2] += (targetPositions[j+2] - p[j+2]) * 0.05;
    }
    geometry.attributes.position.needsUpdate = true;

    particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.05;
    particles.rotation.y += (targetRotation.y - particles.rotation.y) * 0.05;
    particles.rotation.z += 0.001;

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

