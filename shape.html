<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            transform: scaleX(-1);
            opacity: 0;
            pointer-events: none;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 12px;
            border-radius: 8px;
            pointer-events: none;
        }

        #top-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(6px);
        }

        #top-btn:hover {
            background: rgba(255,255,255,0.15);
        }
    </style>
</head>
<body>

<button id="top-btn">Change Shape</button>

<div id="instructions">
    <h3>Hand Controls</h3>
    <p>üñê <b>Move Hand:</b> Rotate Particles</p>
    <p>üëå <b>Pinch:</b> Switch Shape</p>
    <p>Current Shape: <span id="shape-name">Sphere</span></p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ================= CONFIG ================= */
const PARTICLE_COUNT = 15000;
const CAM_DEPTH = 60;

let currentShapeIndex = 0;
let isPinching = false;
let lastPinchTime = 0;

const targetRotation = new THREE.Vector2();
const shapes = ["Sphere", "Heart", "Saturn", "Torus"];

/* ================= THREE SETUP ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = CAM_DEPTH;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

const colorObj = new THREE.Color();

for (let i = 0; i < PARTICLE_COUNT; i++) {
    positions[i*3] = (Math.random() - 0.5) * 100;
    positions[i*3+1] = (Math.random() - 0.5) * 100;
    positions[i*3+2] = (Math.random() - 0.5) * 100;

    colorObj.setHSL(0.55 + Math.random() * 0.1, 0.8, 0.6);
    colors[i*3] = colorObj.r;
    colors[i*3+1] = colorObj.g;
    colors[i*3+2] = colorObj.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
    size: 0.4,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false,
    opacity: 0.85
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ================= SHAPES ================= */
function getPointOnSphere(i) {
    const r = 25;
    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
    return {
        x: r * Math.cos(theta) * Math.sin(phi),
        y: r * Math.sin(theta) * Math.sin(phi),
        z: r * Math.cos(phi)
    };
}

function getPointOnHeart(i) {
    const t = (i / PARTICLE_COUNT) * Math.PI * 2;
    return {
        x: 16 * Math.pow(Math.sin(t), 3),
        y: 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t),
        z: (Math.random() - 0.5) * 10
    };
}

function getPointOnSaturn(i) {
    if (i > PARTICLE_COUNT * 0.7) {
        const a = Math.random() * Math.PI * 2;
        const d = 35 + Math.random() * 15;
        return {
            x: Math.cos(a) * d,
            y: (Math.random() - 0.5) * 2,
            z: Math.sin(a) * d
        };
    }
    return getPointOnSphere(i);
}

function getPointOnTorus() {
    const u = Math.random() * Math.PI * 2;
    const v = Math.random() * Math.PI * 2;
    return {
        x: (20 + 8 * Math.cos(v)) * Math.cos(u),
        y: (20 + 8 * Math.cos(v)) * Math.sin(u),
        z: 8 * Math.sin(v)
    };
}

function setShape(type) {
    document.getElementById("shape-name").innerText = shapes[type];

    let hue = [0.55, 0.0, 0.12, 0.3][type];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let p;
        if (type === 0) p = getPointOnSphere(i);
        if (type === 1) p = getPointOnHeart(i);
        if (type === 2) p = getPointOnSaturn(i);
        if (type === 3) p = getPointOnTorus();

        targetPositions[i*3] = p.x;
        targetPositions[i*3+1] = p.y;
        targetPositions[i*3+2] = p.z;

        colorObj.setHSL(hue + Math.random()*0.08, 0.8, 0.5);
        colors[i*3] = colorObj.r;
        colors[i*3+1] = colorObj.g;
        colors[i*3+2] = colorObj.b;
    }

    geometry.attributes.color.needsUpdate = true;
}

setShape(0);

/* ================= BUTTON ================= */
document.getElementById("top-btn").onclick = () => {
    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
    setShape(currentShapeIndex);
};

/* ================= MEDIAPIPE ================= */
const videoElement = document.createElement("video");

const hands = new Hands({
    locateFile: file =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(results => {
    if (!results.multiHandLandmarks) return;

    const lm = results.multiHandLandmarks[0];
    const indexTip = lm[8];
    const thumbTip = lm[4];

    const x = -(indexTip.x - 0.5) * 2;
    const y = (indexTip.y - 0.5) * 2;

    targetRotation.y = THREE.MathUtils.clamp(x * 2.2, -1.2, 1.2);
    targetRotation.x = THREE.MathUtils.clamp(y * 2.2, -1.2, 1.2);

    const pinchDist = Math.hypot(
        indexTip.x - thumbTip.x,
        indexTip.y - thumbTip.y
    );

    if (pinchDist < 0.05 && !isPinching && Date.now() - lastPinchTime > 1000) {
        isPinching = true;
        lastPinchTime = Date.now();
        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        setShape(currentShapeIndex);
    }

    if (pinchDist > 0.06) isPinching = false;
});

const cam = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({ image: videoElement });
    },
    width: 640,
    height: 480
});
cam.start();

/* ================= ANIMATE ================= */
function animate() {
    requestAnimationFrame(animate);

    const arr = geometry.attributes.position.array;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const j = i * 3;
        arr[j] += (targetPositions[j] - arr[j]) * 0.05;
        arr[j+1] += (targetPositions[j+1] - arr[j+1]) * 0.05;
        arr[j+2] += (targetPositions[j+2] - arr[j+2]) * 0.05;
    }

    geometry.attributes.position.needsUpdate = true;

    particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.08;
    particles.rotation.y += (targetRotation.y - particles.rotation.y) * 0.08;
    particles.rotation.z += 0.001;

    renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

