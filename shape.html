<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Controlled 3D Particles</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
}

video {
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(-1); /* mirror camera */
    opacity: 0;
    pointer-events: none;
}

#instructions {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 8px;
}

#back-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 10;
    padding: 10px 16px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    border: 1px solid cyan;
    border-radius: 8px;
    cursor: pointer;
}
</style>
</head>

<body>

<button id="back-btn" onclick="location.href='index.html'">‚¨Ö Back</button>

<div id="instructions">
    <h3>Hand Controls</h3>
    <p>üñê Move Hand: Rotate Particles</p>
    <p>üëå Pinch: Change Shape</p>
    <p>Current Shape: <span id="shape-name">Sphere</span></p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
/* ---------------- CONFIG ---------------- */
const PARTICLE_COUNT = 15000;
let currentShapeIndex = 0;
let isPinching = false;
let lastPinchTime = 0;

const targetRotation = new THREE.Vector2();
const shapes = ['Sphere', 'Torus'];

/* ---------------- THREE ---------------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 60;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------------- PARTICLES ---------------- */
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
    positions[i*3] = (Math.random()-0.5)*100;
    positions[i*3+1] = (Math.random()-0.5)*100;
    positions[i*3+2] = (Math.random()-0.5)*100;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const particles = new THREE.Points(
    geometry,
    new THREE.PointsMaterial({
        size: 0.4,
        color: 0x00ffff,
        transparent: true
    })
);
scene.add(particles);

/* ---------------- SHAPES ---------------- */
function sphere(i){
    const r = 25;
    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
    return {
        x: r * Math.cos(theta) * Math.sin(phi),
        y: r * Math.sin(theta) * Math.sin(phi),
        z: r * Math.cos(phi)
    };
}

function torus(){
    const u = Math.random()*Math.PI*2;
    const v = Math.random()*Math.PI*2;
    return {
        x: (20 + 8*Math.cos(v))*Math.cos(u),
        y: (20 + 8*Math.cos(v))*Math.sin(u),
        z: 8*Math.sin(v)
    };
}

function setShape(type){
    document.getElementById('shape-name').innerText = shapes[type];
    for(let i=0;i<PARTICLE_COUNT;i++){
        const p = type === 0 ? sphere(i) : torus();
        targetPositions[i*3]   = p.x;
        targetPositions[i*3+1] = p.y;
        targetPositions[i*3+2] = p.z;
    }
}
setShape(0);

/* ---------------- MEDIAPIPE ---------------- */
const videoElement = document.createElement('video');

const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
    maxNumHands: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
});

hands.onResults(onResults);

const cam = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({ image: videoElement });
    },
    width: 640,
    height: 480
});
cam.start();

/* ---------------- HAND RESULTS ---------------- */
function onResults(results){
    if (!results.multiHandLandmarks) return;

    const lm = results.multiHandLandmarks[0];
    const index = lm[8];
    const thumb = lm[4];

    /* üî• FIXED MIRROR ROTATION */
    const x = -(index.x - 0.5) * 2;
    const y = -(index.y - 0.5) * 2;

    targetRotation.x = y * 2;
    targetRotation.y = x * 2;

    /* PINCH */
    const d = Math.hypot(index.x - thumb.x, index.y - thumb.y);
    if (d < 0.05 && !isPinching && Date.now()-lastPinchTime>1000){
        isPinching = true;
        lastPinchTime = Date.now();
        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        setShape(currentShapeIndex);
    }
    if (d >= 0.05) isPinching = false;
}

/* ---------------- ANIMATE ---------------- */
function animate(){
    requestAnimationFrame(animate);

    const p = geometry.attributes.position.array;
    for(let i=0;i<PARTICLE_COUNT;i++){
        const j=i*3;
        p[j]   += (targetPositions[j]-p[j]) * 0.05;
        p[j+1] += (targetPositions[j+1]-p[j+1]) * 0.05;
        p[j+2] += (targetPositions[j+2]-p[j+2]) * 0.05;
    }
    geometry.attributes.position.needsUpdate = true;

    particles.rotation.x += (targetRotation.x - particles.rotation.x)*0.05;
    particles.rotation.y += (targetRotation.y - particles.rotation.y)*0.05;

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize',()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>


