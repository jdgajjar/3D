
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Face Particle Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #video {
            display: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">Initializing webcam...</div>
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <script>
        // Three.js Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Particle System Setup
        const numParticles = 468; // MediaPipe face mesh landmarks
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(numParticles * 3);
        
        // Initialize particles at origin
        for (let i = 0; i < numParticles * 3; i++) {
            positions[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Glowing particle material
        const material = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.08,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Add ambient glow
        const particleGlow = new THREE.PointLight(0x00ffff, 1, 10);
        scene.add(particleGlow);

        // MediaPipe Face Mesh Setup
        const videoElement = document.getElementById('video');
        const infoElement = document.getElementById('info');

        const faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onResults);

        // Process face landmarks
        function onResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const positions = particles.geometry.attributes.position.array;

                // Map face landmarks to 3D particles
                for (let i = 0; i < landmarks.length; i++) {
                    const landmark = landmarks[i];
                    
                    // Convert normalized coordinates to 3D space
                    // MediaPipe gives x,y normalized [0,1] and z depth
                    positions[i * 3] = (landmark.x - 0.5) * 6;      // X: centered and scaled
                    positions[i * 3 + 1] = -(landmark.y - 0.5) * 6; // Y: inverted and scaled
                    positions[i * 3 + 2] = -landmark.z * 3;         // Z: depth
                }

                particles.geometry.attributes.position.needsUpdate = true;
                
                // Update glow position to center of face
                particleGlow.position.set(
                    positions[0],
                    positions[1],
                    positions[2]
                );

                infoElement.textContent = `Tracking ${landmarks.length} face landmarks`;
            } else {
                infoElement.textContent = 'No face detected';
            }
        }

        // Start webcam
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate particle cloud slowly
            particles.rotation.y += 0.001;
            
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Grant camera permission info
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(() => {
                infoElement.textContent = 'Camera ready. Position your face...';
            })
            .catch((err) => {
                infoElement.textContent = 'Camera permission denied: ' + err.message;
            });
    </script>
</body>
</html>
