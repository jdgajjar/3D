<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Real-Time 3D Holographic Mirror</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        /* Hidden elements used for data processing */
        video { display: none; }
        canvas#buffer { display: none; }
        
        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: #00ffcc; font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.8); padding: 15px;
            border: 1px solid #00ffcc; border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h3>// HOLOGRAM_ENGINE</h3>
        <p>Initializing sensor array...</p>
        <p>► MOVE MOUSE to rotate view</p>
        <p>► BRIGHTNESS controls depth</p>
    </div>

    <video id="video" autoplay playsinline></video>
    <canvas id="buffer"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const SEPARATION = 4;      // Distance between particles
        const AMOUNTX = 160;       // Resolution X (Lower = faster)
        const AMOUNTY = 120;       // Resolution Y
        const DEPTH_STRENGTH = 150; // How much brightness pushes particles forward

        let container, camera, scene, renderer;
        let particles, count = 0;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        // Video & Data Vars
        const video = document.getElementById('video');
        const bufferCanvas = document.getElementById('buffer');
        const ctx = bufferCanvas.getContext('2d');
        let isVideoReady = false;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            // 1. SETUP CAMERA
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 800; // Move back to see the grid
            camera.position.y = 300; 

            scene = new THREE.Scene();

            // 2. SETUP WEBCAM
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = { video: { width: 640, height: 480, facingMode: 'user' } };
                navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
                    video.srcObject = stream;
                    video.play();
                }).catch(function(error) {
                    console.error("Camera error:", error);
                    document.querySelector('#ui p').innerText = "ERROR: Camera access denied.";
                });
            }

            video.addEventListener('loadeddata', function() {
                // Set buffer canvas size to match our particle grid resolution, not the full video size
                // This optimizes performance significantly.
                bufferCanvas.width = AMOUNTX;
                bufferCanvas.height = AMOUNTY;
                isVideoReady = true;
            });

            // 3. CREATE PARTICLE SYSTEM
            const numParticles = AMOUNTX * AMOUNTY;
            const positions = new Float32Array(numParticles * 3);
            const colors = new Float32Array(numParticles * 3);
            const scales = new Float32Array(numParticles);

            let i = 0, j = 0;
            for (let ix = 0; ix < AMOUNTX; ix++) {
                for (let iy = 0; iy < AMOUNTY; iy++) {
                    // Center the grid
                    positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // x
                    positions[i + 1] = 0; // y (height) - controlled by brightness later
                    positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // z
                    
                    // Default Color (Cyan)
                    colors[i] = 0;
                    colors[i + 1] = 1;
                    colors[i + 2] = 1;

                    scales[j] = 1;

                    i += 3;
                    j++;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));

            // Custom Material to make particles look like digital pixels
            const material = new THREE.PointsMaterial({
                size: 2.5,
                vertexColors: true,
                color: 0xffffff,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 4. RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Interaction
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            // Calculate mouse position relative to center
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            if (isVideoReady) {
                // A. Draw video frame to small buffer canvas
                // We draw it mirrored to feel like a mirror
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -AMOUNTX, 0, AMOUNTX, AMOUNTY);
                ctx.restore();

                // B. Get pixel data
                const imageData = ctx.getImageData(0, 0, AMOUNTX, AMOUNTY);
                const data = imageData.data; // The array of RGBA values

                const positions = particles.geometry.attributes.position.array;
                const colors = particles.geometry.attributes.color.array;

                let i = 0; // index for positions/colors (x,y,z / r,g,b)
                let pixelIndex = 0; // index for pixel data (r,g,b,a)

                // Loop through every particle
                for (let ix = 0; ix < AMOUNTX; ix++) {
                    for (let iy = 0; iy < AMOUNTY; iy++) {
                        
                        // Extract RGB
                        const r = data[pixelIndex] / 255;
                        const g = data[pixelIndex + 1] / 255;
                        const b = data[pixelIndex + 2] / 255;
                        
                        // Calculate Brightness (Luminance)
                        const brightness = (r + g + b) / 3.0;

                        // 1. UPDATE POSITION (Y-UP)
                        // Brighter pixels move UP/Forward. 
                        // Note: In Three.js "Y" is usually UP. We map grid to X/Z plane and displace Y.
                        // Or we can map grid to X/Y plane and displace Z. Let's displace Y for a "Pin Art" table effect.
                        
                        // Let's create a "Standing Wall" effect instead
                        // Grid is X/Y, Depth is Z.
                        
                        // Re-mapping positions to match video coordinates
                        // ix goes 0 to AMOUNTX
                        const currentY = -(iy * SEPARATION) + ((AMOUNTY * SEPARATION) / 2); // Flip Y to match screen
                        
                        // Displace Z based on brightness
                        // Brighter = Closer to camera
                        const zDepth = brightness * DEPTH_STRENGTH;

                        positions[i + 2] = zDepth; // Update Z

                        // 2. UPDATE COLOR
                        colors[i] = r;
                        colors[i + 1] = g;
                        colors[i + 2] = b;

                        pixelIndex += 4; // Skip to next pixel (RGBA)
                        i += 3; // Skip to next particle (XYZ)
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;
            }

            // Smooth Camera Rotation based on Mouse
            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY + 200 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
