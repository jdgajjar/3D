<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Human Particle Tracker</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #webcam { display: none; }
        #status { 
            position: absolute; top: 10px; left: 10px; 
            color: #0f0; font-family: monospace; 
            background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="status">Initializing...</div>
    <video id="webcam" autoplay playsinline></video>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    
    <!-- MediaPipe Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.min.js"></script>

    <script>
        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 5;

        // Particle System
        const particleCount = 33; // 33 pose landmarks
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Trail effect with lines
        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array(particleCount * 3);
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3
        });
        
        const connections = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(connections);

        // Webcam Setup
        const videoElement = document.getElementById('webcam');
        const statusDiv = document.getElementById('status');
        
        // MediaPipe Pose
        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
        });
        
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onPoseResults);

        // Process pose landmarks
        function onPoseResults(results) {
            if (results.poseLandmarks) {
                statusDiv.textContent = 'Tracking Active';
                
                const posAttr = particles.geometry.attributes.position;
                const colAttr = particles.geometry.attributes.color;
                
                results.poseLandmarks.forEach((landmark, i) => {
                    // Convert normalized coordinates to 3D space
                    const x = (landmark.x - 0.5) * 4;
                    const y = -(landmark.y - 0.5) * 4;
                    const z = -landmark.z * 2;
                    
                    posAttr.array[i * 3] = x;
                    posAttr.array[i * 3 + 1] = y;
                    posAttr.array[i * 3 + 2] = z;
                    
                    // Glowing color gradient
                    const hue = i / particleCount;
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
                    colAttr.array[i * 3] = color.r;
                    colAttr.array[i * 3 + 1] = color.g;
                    colAttr.array[i * 3 + 2] = color.b;
                });
                
                posAttr.needsUpdate = true;
                colAttr.needsUpdate = true;
                
                // Update line connections
                updateConnections(results.poseLandmarks);
            } else {
                statusDiv.textContent = 'No Pose Detected';
            }
        }

        // Draw skeleton connections
        function updateConnections(landmarks) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 7],
                [0, 4], [4, 5], [5, 6], [6, 8],
                [9, 10], [11, 12], [11, 13], [13, 15],
                [15, 17], [15, 19], [15, 21],
                [12, 14], [14, 16], [16, 18], [16, 20], [16, 22],
                [11, 23], [12, 24], [23, 24],
                [23, 25], [24, 26], [25, 27], [26, 28],
                [27, 29], [28, 30], [27, 31], [28, 32]
            ];
            
            const linePos = lineGeometry.attributes.position;
            let idx = 0;
            
            connections.forEach(([start, end]) => {
                const startLm = landmarks[start];
                const endLm = landmarks[end];
                
                linePos.array[idx++] = (startLm.x - 0.5) * 4;
                linePos.array[idx++] = -(startLm.y - 0.5) * 4;
                linePos.array[idx++] = -startLm.z * 2;
                
                linePos.array[idx++] = (endLm.x - 0.5) * 4;
                linePos.array[idx++] = -(endLm.y - 0.5) * 4;
                linePos.array[idx++] = -endLm.z * 2;
            });
            
            linePos.needsUpdate = true;
        }

        // Start webcam
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 }
                });
                videoElement.srcObject = stream;
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await pose.send({ image: videoElement });
                    },
                    width: 1280,
                    height: 720
                });
                camera.start();
                
                statusDiv.textContent = 'Camera Started';
            } catch (error) {
                statusDiv.textContent = 'Camera Error: ' + error.message;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate scene slowly
            particles.rotation.y += 0.002;
            connections.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        startCamera();
        animate();
    </script>
</body>
</html>
