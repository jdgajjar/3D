<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Real-Time Multi Face 3D Particle Tracker</title>

<style>
  body { margin: 0; overflow: hidden; background: black; }
  video { display: none; }

  #goShape {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    padding: 12px 22px;
    background: rgba(0, 255, 255, 0.15);
    color: #00ffff;
    border: 1px solid #00ffff;
    border-radius: 10px;
    cursor: pointer;
  }
</style>
</head>
<body>

<button id="goShape">Go to Shape Page</button>
<video id="video" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===== CONFIG ===== */
const MIRROR_X = -1; // ðŸ”¥ FIX
const MAX_FACES = 5;
const LANDMARKS = 468;

/* ===== THREE ===== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== FACE STORAGE ===== */
const faceParticles = [];

function createFace(color) {
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(new Float32Array(LANDMARKS*3), 3));
  const mat = new THREE.PointsMaterial({
    size: 0.05,
    color,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending
  });
  const points = new THREE.Points(geo, mat);
  scene.add(points);
  return points;
}

/* ===== MEDIAPIPE ===== */
const video = document.getElementById("video");
const faceMesh = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});

faceMesh.setOptions({
  maxNumFaces: MAX_FACES,
  refineLandmarks: true
});

faceMesh.onResults(res => {
  if (!res.multiFaceLandmarks) return;

  while (faceParticles.length > res.multiFaceLandmarks.length) {
    scene.remove(faceParticles.pop());
  }

  res.multiFaceLandmarks.forEach((lmks, i) => {
    if (!faceParticles[i]) {
      faceParticles[i] = createFace(new THREE.Color().setHSL(i/MAX_FACES,1,0.5));
    }

    const arr = faceParticles[i].geometry.attributes.position.array;

    lmks.forEach((lm, j) => {
      arr[j*3]     = MIRROR_X * (lm.x - 0.5) * 6 + i * 2;
      arr[j*3 + 1] = -(lm.y - 0.5) * 6;
      arr[j*3 + 2] = -lm.z * 4;
    });

    faceParticles[i].geometry.attributes.position.needsUpdate = true;
  });
});

/* ===== CAMERA ===== */
new Camera(video, {
  onFrame: async () => await faceMesh.send({ image: video }),
  width: 640,
  height: 480
}).start();

/* ===== LOOP ===== */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

/* ===== NAV ===== */
document.getElementById("goShape").onclick = () => {
  location.href = "shape.html";
};

window.addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
