<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Real-Time Multi Face 3D Particle Tracker</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  video { display:none; }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= SCENE ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth/window.innerHeight, 0.1, 1000
);
camera.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= FACE STORAGE ================= */
const MAX_FACES = 5;
const LANDMARKS = 468;
const faceParticles = [];

/* ================= CREATE FACE ================= */
function createFace(color) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(LANDMARKS * 3);
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.05,
    color,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending
  });

  const points = new THREE.Points(geo, mat);
  scene.add(points);
  return points;
}

/* ================= MEDIAPIPE ================= */
const video = document.getElementById("video");

const faceMesh = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});

faceMesh.setOptions({
  maxNumFaces: MAX_FACES,
  refineLandmarks: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

faceMesh.onResults(results => {
  // Remove extra faces
  while (faceParticles.length > results.multiFaceLandmarks.length) {
    scene.remove(faceParticles.pop());
  }

  results.multiFaceLandmarks.forEach((landmarks, i) => {
    if (!faceParticles[i]) {
      faceParticles[i] = createFace(
        new THREE.Color().setHSL(i / MAX_FACES, 1, 0.5)
      );
    }

    const arr = faceParticles[i].geometry.attributes.position.array;

    landmarks.forEach((lm, j) => {
      arr[j*3]     = (lm.x - 0.5) * 6 + i * 2;
      arr[j*3 + 1] = -(lm.y - 0.5) * 6;
      arr[j*3 + 2] = -lm.z * 4;
    });

    faceParticles[i].geometry.attributes.position.needsUpdate = true;
  });
});

/* ================= CAMERA ================= */
const cam = new Camera(video, {
  onFrame: async () => await faceMesh.send({ image: video }),
  width: 640,
  height: 480
});
cam.start();

/* ================= LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  faceParticles.forEach(f => {
    f.rotation.y += 0.001;
  });

  renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
